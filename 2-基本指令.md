# §2.基本指令

## 前言

> 使计算机更好用！这是操作系统的根本要义！

## whoami

可以查到哪个用户登录我的系统。

## who

当前有哪些用户正在我的系统当中。

## pwd

> [!IMPORTANT]
>
> 显示当前我所在的目录。Print Working Directory（打印工作目录）
>
> ![image-20240811223013145](2-基本指令.assets/image-20240811223013145.png)

Windows也有这样的概念。

![image-20240811223303827](2-基本指令.assets/image-20240811223303827.png)

![image-20240811223345343](2-基本指令.assets/image-20240811223345343.png)

## ls

> [!IMPORTANT]
>
> 查看当前目录下的文件信息。list（列出文件和目录）
>
> 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出**文件名**。
>
> ls -l 
>
> l 就是 list ，显示文件的属性列表。

> [!TIP]
>
> 问：如果在Windows上新建一个空文件，这个文件要占据磁盘空间吗？
>
> 答：一定会占据空间，虽然文件里没有任何内容，但是诸如文件名，文件的创建时间，文件类型等这些文件的属性也是数据。站在计算机的角度上它们都是二进制，也要被计算机记录和存储下来。所以不要狭隘的认为只有文件内容才占据空间。
>
> 还说明**文件 = 文件内容 + 文件属性。**
>
> 所以全部的文件操作要么对文件内容进行操作，要么对文件属性进行操作。绝对不会脱离这两种。

> [!IMPORTANT]
>
> ls -a
>
> 列出目录下的所有文件，包括以 . 开头的隐含文件，那么也就说明 -l 不会显示隐藏文件。
>
> ls -la
>
> 更加详细的
>
> ![image-20240810231420124](2-基本指令.assets/image-20240810231420124.png)

> [!TIP]
>
> ls -la 等价于ls -al 也等价于 ls -l -a 也等价于 ls -a -l，可以分开写，也可写到一起。在操作上没有任何的差别。
>
> 在Windows下面也是有隐藏的文件。
>
> ![image-20240810232825137](2-基本指令.assets/image-20240810232825137.png)

> [!TIP]
>
> 除了 ls 外，还有 ll 命令。
>
> **ll会列出该文件下的所有文件信息，包括隐藏的文件，而ls -l只列出显式文件**
>
> ![image-20240811221307524](2-基本指令.assets/image-20240811221307524.png)



## clear

清屏

## cd

更改工作目录。change directory（改变目录）

在Windows上想要进去一个目录，只需要使用鼠标点击即可。那么在Linux下，应该怎么进入呢？

我们先创建一个code目录，mkdir后文会说到。

```cmd
mkdir code
```

我们使用 ls 或者 ls -la查看一下，就会发现已经创建成功。

![image-20240811224257707](2-基本指令.assets/image-20240811224257707.png)

我们再使用 pwd 命令显示我当前所在的目录，是 /root。

![image-20240811225053586](2-基本指令.assets/image-20240811225053586.png)

我们再使用 cd code，更改目录到 /root/code。

![image-20240811225138972](2-基本指令.assets/image-20240811225138972.png)

我们再使用 pwd 查看一下当前工作目录，发现已经变到 /root/code。

![image-20240811225438159](2-基本指令.assets/image-20240811225438159.png)

> [!TIP]
>
> Linux下的目录结构是怎么样的？
>
> 我们刚才是新建了一个 code 目录，那我们怎么改变本身已经有的文件？Windows上的C盘等等很多文件是本身就有的，通过鼠标就可以点击。
>
> 前文提到 . 开头的是隐藏文件。我们使用 ls -a 查看隐藏文件或者 ls -la 查看更加详细的。发现有 **.** 和 **..** 的。这又是什么意思呢？
>
> ![image-20240811230800415](2-基本指令.assets/image-20240811230800415.png)
>
> 其中 **.** 是当前路径，**..** 是上级路径。
>
> 我们可以使用 cd 命令来验证一下，首先使用 **cd .** 更改到当前路径，再使用 pwd 显示当前目录。
>
> ![image-20240811231430645](2-基本指令.assets/image-20240811231430645.png)
>
> 我们发现没有变化，那说明 . 就是当前路径。
>
> 我们再使用 **cd ..** 回退到上级路径，再使用 pwd 显示当前目录。 
>
> ![image-20240811231620884](2-基本指令.assets/image-20240811231620884.png)
>
> 我们发现它确实更改到上级路径了。
>
> 再**cd ..** 又回退到上一级目录了。
>
> 类似于Windows上的 左箭头。
>
> ![image-20240811232516123](2-基本指令.assets/image-20240811232516123.png)
>
> ![image-20240811232609341](2-基本指令.assets/image-20240811232609341.png)
>
> ![image-20240811232629060](2-基本指令.assets/image-20240811232629060.png)
>
> 我们经常说路径，那什么叫路径呢？
>
> 路径是引用文件和目录的方式。它给出了目录结构中文件或目录的位置。它由名称和斜杠语法组成。
>
> ```cmd
> /root/code
> ```
>
> ```cmd
> C:\Windows\Branding\Basebrd\en-US
> ```
>
> 上面的是Linux下的路径，下面的是Windows下的路径，我们仔细观察可以发现有个区别。一个是斜杠 ，一个是反斜杠 ，前者是Linux下的路径分隔符，后者自然就是Windows下的路径分隔符。
>
> 两个路径分隔符中间一定是目录（文件夹），最后可能是文件也可能是文件夹。
>
> 那么通俗来说，路径分隔符分隔的由一串文件夹构成的字符串叫做路径。
>
> ![image-20240811234215776](2-基本指令.assets/image-20240811234215776.png)
>
> 我们可以将 **cd .** 理解为 /root/code 这一个路径，也可以理解为 code 这个文件夹。
>
> 我一直 **cd ..**，最后发现只剩一个 / ，继续 **cd ..** 也没法再回退了。
>
> ![image-20240811234648940](2-基本指令.assets/image-20240811234648940.png)
>
> 我们把只有 / 的这个东西叫做 Linux 的根目录。
>
> 我们可以看一下根目录都有哪些东西。
>
> ![image-20240811235004663](2-基本指令.assets/image-20240811235004663.png)
>
> 以 d 开头的就是目录。
